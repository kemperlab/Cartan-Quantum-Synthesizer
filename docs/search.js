window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "CQS", "modulename": "CQS", "type": "module", "doc": "<p>Welcome to the Cartan Quantum Synthesizer package. For useage examples, please see package.util.examples or the README</p>\n\n<h2 id=\"general-usage\">General Usage:</h2>\n\n<p>This package makes use of three object classes: The Hamiltonian, the Cartan, and the FindParameters objects.</p>\n\n<ol>\n    <li> <code>Hamiltonian</code>: The Hamiltonian object is used to construct information about the model that you wish to simulate. There are predefined models that can be used for example implementation, the user can define a custom Hamiltonian and pass it to the object, the user can combine existing Hamiltonians to generate the desired Hamiltonian (ex. XY + transverse field), or the user can define their own input. This is designed to be relatively straightforward, and the other definitions can serve as examples </li>\n    <li> <code>Cartan</code>: The Cartan object is used to define a cartan decomposition on the \"Hamiltonian Algebra\" generated by Hamiltonian object. The \"Hamiltonian Algebra, g(H) or g, is defined as the set of Pauli Strings that can be generated through nested commutators on the Hamiltonian. Thus, g(H) is a closed Lie algebra. We can then perform a Cartan decomposition, which splits g into two components, k and m, based on some involution. The Cartan object has a list of predefined Cartan involutions, although users are encouraged to add an name their own implementations. Finally, the Hamiltonian algebra has as Cartan Subalgebra h, which is a maximal abelian subalgebra that is contained within the m partition. This is generated by the object.  After generated the Cartan object, the involution (k and m) can be altered, and h can be regenerated based on a list of commuting terms in m. h is generally not unique. </li>\n    <li> <code>FindParameters</code>: The FindParameters object optimizes the terms in the cartan decomposition to generate a time evolution circuit for the Hamiltonian. For details of the theory, please see the paper. The Find Parameters object relies on a cost function formulated by Earp and Pachos and improved in the original paper by Kokcu et. al. The Find Parameters object takes a filename, a Cartan object (which contains a Hamiltonian object), and allows for changes in the optimizer function (ex. BFGS gradient decent or Powell), or the optimization accuracy. Warning: Runtime scales quickly with system size. </li>\n</ol>\n\n<p>package.util contains functions useful for generating the above objects or for verifying the correctness through exact matrix exponentiation. These functions might be generally useful, so they are set-aside from the above objects. </p>\n\n<p>Finally, the examples file provides code for verifying the correctness of the methods and for understanding the usage.</p>\n"}, {"fullname": "CQS.methods", "modulename": "CQS.methods", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.methods.Hamiltonian", "modulename": "CQS.methods", "qualname": "Hamiltonian", "type": "class", "doc": "<p>Class contains information about the Hamiltonian to be decomposed.</p>\n\n<h2 id=\"functionality\">Functionality:</h2>\n\n<ul>\n<li>Build Hamiltonians from prebuilt Spin models</li>\n<li>Add custom Hamiltonians </li>\n</ul>\n\n<p>TODO:</p>\n\n<ul>\n<li>Add Hubbard Model</li>\n</ul>\n\n<p>Authors:</p>\n\n<ul>\n<li>Thomas Steckmann</li>\n<li>Efekan Kokcu</li>\n</ul>\n"}, {"fullname": "CQS.methods.Hamiltonian.__init__", "modulename": "CQS.methods", "qualname": "Hamiltonian.__init__", "type": "function", "doc": "<p>Initializes an empty Hamiltonian, unless name is specified</p>\n\n<p>name is not required as an input to initialize the Hamiltonian, only the number of qubits. After initializing the Hamiltonian, users can use addModel() to add a single, implemented Hamiltonian at a time and use .addTerms() to add lists of terms or individual terms. .removeTerm() can be used to remove a single term at a time</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>qubits (int):</strong>  The number of lattice points the Hamiltonian exists on</li>\n<li><p><strong>name (List of Tuples):</strong>  Easily build Hamiltonians from native models. </p>\n\n<h3 id=\"options\">Options:</h3>\n\n<ul>\n<li><code>[(coefficient, 'modelname', periodic boundary conditions boolean)]</code> - Builds a single Hamiltonian with constant coefficient. Periodic boundary conditions are true or false, false is assumed if not specified</li>\n<li><code>[([list of coefficients], 'modelname')]</code> - Populates the Hamiltonian using the list of coefficients. Lengths must match</li>\n<li><p><code>[(coefficient, 'modelname1'),([list of coefficients], 'modelname2')]</code> - Combines two Hamiltonians. Order my alter default choice of \ud835\udd8d</p>\n\n<h4 id=\"examples\">Examples:</h4></li>\n<li><p><code>[(1,'xy', True)]</code> on three qubits gives: XXI + YYI + IXX + IYY + XIX + YIY</p></li>\n<li><p><code>[([1,2],'kitaevEven')]</code> on three qubits gives: 1<em>XXI + 2</em>IYY </p>\n\n<h3 id=\"currently-implemented-models\">Currently Implemented Models:</h3></li>\n<li><p>xy: (XX + YY)</p></li>\n<li>xx: (XXI + IXX)</li>\n<li>yy: (YYI + IYY)</li>\n<li>zz: (ZZI + IZZ)</li>\n<li>tfim: (ZZ + XI + IX)</li>\n<li>tfxy: (XX + YY + ZI + IZ)</li>\n<li>transverse_z: (IZ + ZI)</li>\n<li>kitaev_even: (XXI + IYY)</li>\n<li>kitaev_odd: (YYI + IXX)</li>\n<li>heisenberg: (XX + YY + ZZ)</li>\n<li>TODO: hubbard: (XXII + YYII + IIXX + IIYY + ZIZI + IZIZ)</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sites</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "CQS.methods.Hamiltonian.addModel", "modulename": "CQS.methods", "qualname": "Hamiltonian.addModel", "type": "function", "doc": "<p>Adds a predefined model to the Hamiltonian object</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>pair (Tuple):</strong>   ### Currently Implemented Models:\n<ul>\n<li>xy: (XX + YY)</li>\n<li>xx: (XXI + IXX)</li>\n<li>yy: (YYI + IYY)</li>\n<li>zz: (ZZI + IZZ)</li>\n<li>tfim: (ZZ + XI + IX)</li>\n<li>tfxy: (XX + YY + ZI + IZ)</li>\n<li>transverse_z: (IZ + ZI)</li>\n<li>kitaev_even: (XXI + IYY)</li>\n<li>kitaev_odd: (YYI + IXX)</li>\n<li>heisenberg: (XX + YY + ZZ)</li>\n<li>TODO: hubbard: (XXII + YYII + IIXX + IIYY + ZIZI + IZIZ)</li>\n</ul></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError:</strong>   Coefficient list length mismatch</li>\n<li><strong>Exception:</strong>  Invalid model type input</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pair</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Hamiltonian.addTerms", "modulename": "CQS.methods", "qualname": "Hamiltonian.addTerms", "type": "function", "doc": "<p>Adds custom elements to build out the Hamiltonian</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>pair (List of Tuples or Tuple of Lists or Tuple):</strong>  Formatted as either\n<ul>\n<li><code>[(coefficient, PauliString), (coefficient, PauliStringTuple),...]</code></li>\n<li><code>(coefficient, (PauliString))</code></li>\n<li>`([coefficienList],[(PauliStringList)])</li>\n</ul></li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<blockquote>\n  <ul>\n  <li><code>Hamiltonian.addTerms((0.45, (1,3,2,0,0,0)))</code></li>\n  <li>`Hamiltonian.addTerms([(1,(1,1,0,0)),(2,(2,2,0,0))])</li>\n  <li><code>Hamiltonian.addTerms(([co1, co2, co3, ...],[(PauliString1),(PauliString2),(PauliString3)...])</code></li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pairs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Hamiltonian.removeTerm", "modulename": "CQS.methods", "qualname": "Hamiltonian.removeTerm", "type": "function", "doc": "<p>Removes the term matching the tuple input. Used for trimming terms off the Hamiltonian</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tup (tuple):</strong>  A (pauliString)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tup</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Hamiltonian.generateHamiltonian", "modulename": "CQS.methods", "qualname": "Hamiltonian.generateHamiltonian", "type": "function", "doc": "<p>Helper Function to generate Hamiltonians.</p>\n\n<p>From the model type, generates the Hamiltonian Pauli Strings</p>\n\n<p>Args: \n    modelType (Tuple of Strings): See previous documentation\n    closed (bool): \n        True if the model is period.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">modelType</span>, </span><span class=\"param\"><span class=\"n\">closed</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Hamiltonian.getHamiltonian", "modulename": "CQS.methods", "qualname": "Hamiltonian.getHamiltonian", "type": "function", "doc": "<p>Based on the type, returns the Hamiltonian from the object and formats it.\n       Args:\n           type (String, default = 'tuples'): Specifies the return type of the function.\n               Valid inputs:</p>\n\n<pre><code>            - 'tuples': Return formatted as `[(coefficient, (PauliString), ... ]`\n\n            - 'printTuples': Prints out to the console ``(coefficient, (PauliString))\n</code></pre>\n\n<p>...``</p>\n\n<pre><code>            - 'printText': Prints out ``'coefficient * 'PauliString' + ....``\n\n            - 'text': Return formatted as a list of `[[coefficient, 'PauliString']]`\n\n   Returns:\n       For type=`'tuples'` or type=`'text'`, returns\n\n       - `'tuples'`: A list of Coefficient, (PauliString) Tuple pairs\n       - `'text'`: A List of Coefficient 'PauliString' List pairs\n\n   Raises:\n       ValueError: Invalid type\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">type</span><span class=\"o\">=</span><span class=\"s1\">&#39;tuples&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Cartan", "modulename": "CQS.methods", "qualname": "Cartan", "type": "class", "doc": "<p>Class to contain the options for performing Cartan Decomposition on a Hamiltonian</p>\n\n<h1 id=\"object-containing-the-functions-and-data-required-to-generate-a-cartan-decomposition-from-a-given-hamiltonian\">Object containing the functions and data required to generate a Cartan Decomposition from a given Hamiltonian.</h1>\n\n<p>from object_based.PauliOps import commutatePauliString</p>\n\n<p>TODO:</p>\n\n<ul>\n<li>Add in k simplification functions</li>\n</ul>\n\n<p>Authors:</p>\n\n<ul>\n<li>Thomas Steckmann</li>\n<li>Efekan Kokcu</li>\n</ul>\n\n<p>Functionality:</p>\n\n<ul>\n<li>Generate Hamiltonian Algebra</li>\n<li>Generate k, m, h partition</li>\n<li>Choose involution (Default - Even/Odd)</li>\n<li>Seed choice of h</li>\n<li>Modify k (Additional Decomposition, TODO: Abelian Decomposition, Piling)</li>\n</ul>\n"}, {"fullname": "CQS.methods.Cartan.__init__", "modulename": "CQS.methods", "qualname": "Cartan.__init__", "type": "function", "doc": "<p>Generates the Cartan Object</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>hamObj (Hamiltonian):</strong>  Passes a Hamiltonian Object containing the full information about the system</li>\n<li><p><strong>involution (String, default='evenOdd'):</strong>  Allows a choice of the k,m involution</p>\n\n<p>Options:</p>\n\n<ul>\n<li><code>'evenOdd'</code>: m contains an even number of non-identity pauli terms in each string, k contains an odd number of non-identity elements</li>\n<li><code>'knejaGlaser'</code>: m contains elements ending in Y or X, k contains elements ending in I or Z</li>\n<li><code>'count' + 'X', 'Y', or 'Z'</code>: Counts of the number of the specified Pauli Tuple. Even count in m, odd in k</li>\n</ul></li>\n<li><strong>order (int, default = 0):</strong>  g(H) is generated iteratively until it fails to generate new terms. We call each term in H, [H,H], [H,[H,H]], ... order 0, 1, 2, and going up.\nGenerally, the larger the system the larger the order of terms required to generate g(H). Setting the order greater than 0 ensure that g(H) will only result in terms the distance of commutators from H.\nHowever, this results in an incomplete algebra for g. Be warned. </li>\n<li><strong>manualMode (bool, default = 0):</strong>  Choose either 0 (automatic) or 1 (manual). automatic generates h, k, m, and h when the object is created. manual requires the user call the respective functions.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>hamiltonian (:</strong> :hamiltonian:: object): Allows access to HCoefficients and HTuples</li>\n<li><strong>HTuples (List of Tuples):</strong>  Copies over the HTuples from the hamiltonian object</li>\n<li><strong>g (List of Tuples):</strong>  Generates formatted like k + h + (m without h)</li>\n<li><strong>k (List of Tuples):</strong>  Specified by the decomposition. Changing k regenerates h and the order of g (g = k + h + (m\\h))</li>\n<li><strong>h (List of Tuples):</strong>  Specified by SubAlgebra(). Defaults to seeding by m, otherwise allows for inclusion of specific elements</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hamObj</span>, </span><span class=\"param\"><span class=\"n\">involution</span><span class=\"o\">=</span><span class=\"s1\">&#39;evenOdd&#39;</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">manualMode</span><span class=\"o\">=</span><span class=\"mi\">0</span></span>)</span>"}, {"fullname": "CQS.methods.Cartan.decompose", "modulename": "CQS.methods", "qualname": "Cartan.decompose", "type": "function", "doc": "<p>Sets a new Involution using a switch. Regenerates h using the default first element in m</p>\n\n<h6 id=\"options\">Options</h6>\n\n<blockquote>\n  <ul>\n  <li><code>'evenOdd'</code>: m contains an even number of non-identity pauli terms in each string, k contains an odd nunber of non-idenity elements</li>\n  <li><code>'knejaGlaser'</code>: m contains elements ending in Y or X, k contains elements ending in I or Z</li>\n  <li><code>'count' + 'X', 'Y', or 'Z'</code>: Counts of the number of the specified Pauli Tuple. Even count in m, odd in k</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">involutionName</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.makeGroup", "modulename": "CQS.methods", "qualname": "Cartan.makeGroup", "type": "function", "doc": "<p>Returns a closure of a given list of pauli strings (g). The list doesn't include any coefficients, it is just\na tuple like (0,2,3) representing IYZ.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>  A set of Pauli Strings</li>\n<li><strong>order (int, default = 0):</strong>   The number of terms to include in g. If order = 0, generates the full g(H). 0th order is H, 1st is [H,H], and 2nd is [H,[H,H]], etc</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List of Tuples: \ud835\udd8c(H), the Hamiltonian Algebra generated by the input g</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.elemcount", "modulename": "CQS.methods", "qualname": "Cartan.elemcount", "type": "function", "doc": "<p>Counts the number of given elements (X,Y or Z in number), and puts even numbers in m, odd numbers in k. \nFor element=2, it corresponds to \u03b8(g) = -g^T</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">element</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.included", "modulename": "CQS.methods", "qualname": "Cartan.included", "type": "function", "doc": "<p>Following function returns 0 if tuple m is not incu=luded in tuple list g, returns 1 if it is included.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>   The List of Pauli string elements in the Hamiltonian Algebra \ud835\udd8c(H)</li>\n<li><strong>m (Tuple of 0,1,2,3):</strong>  Pauli string in the set \ud835\udd92</li>\n</ul>\n\n<p>Returns: \n    1 if m is in g\n    0 if not</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">m</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.evenOdd", "modulename": "CQS.methods", "qualname": "Cartan.evenOdd", "type": "function", "doc": "<p>Partitions the Algebra by counting the number of non-idenity Pauli elements</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>  The Algebra to partition</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>k (List of Tuples):\n      The List of Pauli Strings with Odd non-identity terms\n  m (List of Tuples):\n      The List of Pauli Strings with Even non-idenity terms</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">g</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.knejaGlaser", "modulename": "CQS.methods", "qualname": "Cartan.knejaGlaser", "type": "function", "doc": "<p>Following one is the Kneja Glaser decomposition. \nIt corresponds to       heta(g) = III...IZ g III..IZ</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">g</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.subAlgebra", "modulename": "CQS.methods", "qualname": "Cartan.subAlgebra", "type": "function", "doc": "<p>Generates h from a list of Commuting elements in the seedList </p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>seedList (List of Tuples):</strong>  List of (PauliStrings). Must be commuting</li>\n</ul>\n\n<h6 id=\"todo\">TODO</h6>\n\n<blockquote>\n  <p>Verify that seedList is commuting</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">seedList</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters", "modulename": "CQS.methods", "qualname": "FindParameters", "type": "class", "doc": "<p>From a Cartan Decomposition, runs the optimizer to find the appropriate parameters for a circuit</p>\n\n<p>Warning: Very long runtime for more than 8ish qubits</p>\n\n<p>Authors:</p>\n\n<ul>\n<li>Thomas Steckmann</li>\n<li>Efekan Kokcu</li>\n</ul>\n"}, {"fullname": "CQS.methods.FindParameters.__init__", "modulename": "CQS.methods", "qualname": "FindParameters.__init__", "type": "function", "doc": "<p>Initializing a FindParameters class automatically runs the optimizer over the Cartan decomposition and provided Hamiltonian</p>\n\n<p>If saveFileName is provided, verifies file location before proceeding, and saves the output as a csv\nIf loadFileName is provided, does not run the optimizer and instead reads data from the provided file</p>\n\n<h6 id=\"todo\">TODO</h6>\n\n<blockquote>\n  <ul>\n  <li>Write Load file functions</li>\n  </ul>\n</blockquote>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cartan (Obj Cartan):</strong>  The Cartan object containing the k,h, and Hamiltonian information</li>\n<li><strong>saveFileName (String, default=None):</strong>  path to save the output. Do not include an extension ('csv' or 'txt')</li>\n<li><strong>loadFileName (String, default=None):</strong>  path to a csv containing previous optimizer results. Do not add .csv or .txt</li>\n<li><p><strong>optimizer (String, default='BFGS'):</strong>  The Scipy optimizer to use. Easy to add new ones, but must be done manually</p>\n\n<p>Options: </p>\n\n<ul>\n<li><code>'BFGS'</code> : Uses Gradient</li>\n<li><code>'Powel'</code>: Does not use Gradient</li>\n</ul></li>\n<li><strong>accuracy (float, default=1e-5):</strong>  Optimizer convergence Criteria</li>\n<li><strong>initialGuess (List of values):</strong>  Allows the user to specify the inital guess for k. Must be correct, no input checking is currently implemented</li>\n<li><strong>steps (int):</strong>  The maximum number of optimization steps before termination</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <ul>\n  <li>Progress updates and runtime predictions</li>\n  <li>prints the results of the optimization</li>\n  </ul>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">cartan</span>,</span><span class=\"param\">\t<span class=\"n\">saveFileName</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">loadfileName</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">optimizerMethod</span><span class=\"o\">=</span><span class=\"s1\">&#39;BFGS&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">accuracy</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">initialGuess</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">steps</span><span class=\"o\">=</span><span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">useCommTables</span><span class=\"o\">=</span><span class=\"kc\">True</span></span>)</span>"}, {"fullname": "CQS.methods.FindParameters.setCommutatorTables", "modulename": "CQS.methods", "qualname": "FindParameters.setCommutatorTables", "type": "function", "doc": "<p>Generates commutator look-up tables for the commutators of different elements</p>\n\n<p>Important: g must be ordered as k + h + (the rest of m). Does not work without this ordering</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.generateIndexLists", "modulename": "CQS.methods", "qualname": "FindParameters.generateIndexLists", "type": "function", "doc": "<p>Generates a lists for H, h, and k using indices in g instead of as lists of Tuples</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.optimize", "modulename": "CQS.methods", "qualname": "FindParameters.optimize", "type": "function", "doc": "<p>Chooses between methods of optimization. Current options are 'BFGS' and 'Powell' from scipy.optimize</p>\n\n<p>Sets the attribute kCoefs, which are the results of the optimizer</p>\n\n<p>Returns: \n    The object returned by the Scipy Optimizer. Contains information about the minimum, parameters, and a few other things</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.generalCostFunction", "modulename": "CQS.methods", "qualname": "FindParameters.generalCostFunction", "type": "function", "doc": "<p>This returns Tr(e<sup>i\u2022thetas1\u2022k1</sup>\u2022v\u2022e<sup>-thetas2\u2022k2</sup>\u2022H)\n(To make it clear, for Earp and Pachos function, we have k1=k2=k, thetas1=thetas2=thetas)</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>thetas1 (List):</strong>  The coefficients for the k_tuples on the left side</li>\n<li><strong>thetas2 (List):</strong>  The coefficients for the K_tuples on the right side</li>\n<li><strong>index (int):</strong>  The number of k elements acting on v</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tr(e<sup>i\u2022thetas1\u2022k1</sup>)\u2022v\u2022e<sup>-thetas2\u2022k2</sup>\u2022H)</p>\n</blockquote>\n\n<p>TODO: \n    * Comment the steps in this section</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">thetas1</span>, </span><span class=\"param\"><span class=\"n\">thetas2</span>, </span><span class=\"param\"><span class=\"n\">index</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.CostFunction", "modulename": "CQS.methods", "qualname": "FindParameters.CostFunction", "type": "function", "doc": "<p>returns Tr(exp(thetas\u2022k)\u2022v\u2022exp(-thetas\u2022k)\u2022H)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">thetas</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.gradCostFunction", "modulename": "CQS.methods", "qualname": "FindParameters.gradCostFunction", "type": "function", "doc": "<p>returns gradient of funky. Order of derivatives is the order of the parameters thetas.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">thetas</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.adj_action", "modulename": "CQS.methods", "qualname": "FindParameters.adj_action", "type": "function", "doc": "<p>Computes Ad<sub>k</sub>(m) = e<sup>i\u2022theta</sup>(coefs \u2022 tuples)e<sup>-i\u2022theta</sup>\nAlso known as the Adjoint Representation</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>theta (float):</strong>  A single value, the coeffient of the k PauilString</li>\n<li><strong>k (Tuple):</strong>  A (PauliString)</li>\n<li><strong>coefs (List of floats, can be complex):</strong>  The coefficients indexed in order of the elements in tuples</li>\n<li><strong>tuples (List of tuples):</strong>  A List of (PauliStrings)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The Algebraic element in m which is the result of the Adjoint Action (Representation)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">theta</span>, </span><span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">coefs</span>, </span><span class=\"param\"><span class=\"n\">tuples</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.sethVecFromk", "modulename": "CQS.methods", "qualname": "FindParameters.sethVecFromk", "type": "function", "doc": "<p>Returns h = exp(-thetas\u2022k)\u2022H\u2022exp(thetas\u2022k)</p>\n\n<p>Defines hErrorTuples and hErrorCoefs, which are the exact result of the adjoint representation. The result is in m, not in h, though it is mostly in h. </p>\n\n<p>hCoefs and hTuples are the results stripped of the components in m</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.errorhVec", "modulename": "CQS.methods", "qualname": "FindParameters.errorhVec", "type": "function", "doc": "<p>Gets the norm square of the part in hcoefs\u2022htuples that is orthogonal to Cartan subalgebra h.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.multiplyLinComb", "modulename": "CQS.methods", "qualname": "FindParameters.multiplyLinComb", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">tuplesA</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">tuplesB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.multiplyPauliString", "modulename": "CQS.methods", "qualname": "FindParameters.multiplyPauliString", "type": "function", "doc": "<p>Computes the multiplication of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple or index in g):</strong>  tuple represenation of the first Pauli String</li>\n<li><strong>b (np.complex128):</strong>  The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (Tuple or index in g):</strong>   tuple represenation of the second Pauli String</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result a\u2022TupleA . b\u2022TupleB = c\u2022TupleC, where c (the sign of the product of Paulis \u2022 a \u2022 b)\n  tupleC (tuple) :\n      the elementwise product of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">tupleA</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">tupleB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.commutatePauliString", "modulename": "CQS.methods", "qualname": "FindParameters.commutatePauliString", "type": "function", "doc": "<p>Computes the commutator of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple, integer):</strong>   tuple represenation of the first Pauli String, or the index in the commutator table</li>\n<li><strong>b (np.complex128):</strong>   The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (tuple, int):</strong>   tuple represenation of the second Pauli String, or the index in the commutator table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result [a\u2022TupleA,b\u2022TupleB] = c\u2022TupleC, where c is the Structure Constant \u2022 a \u2022 b.</p>\n  \n  <p>tupleC (tuple): \n      the elementwise commutator of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">tupleA</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">tupleB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.multiplyLinCombRound", "modulename": "CQS.methods", "qualname": "FindParameters.multiplyLinCombRound", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms, and rounds things that are smaller than accur to zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">tuplesA</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">tuplesB</span>, </span><span class=\"param\"><span class=\"n\">accur</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.printResult", "modulename": "CQS.methods", "qualname": "FindParameters.printResult", "type": "function", "doc": "<p>Prints out the results of the otpimization</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.saveKH", "modulename": "CQS.methods", "qualname": "FindParameters.saveKH", "type": "function", "doc": "<p>Saves the information about the otimization to a .csv file</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util", "modulename": "CQS.util", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.util.IO", "modulename": "CQS.util.IO", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.util.IO.printlist", "modulename": "CQS.util.IO", "qualname": "printlist", "type": "function", "doc": "<p>Function to Print from Tuple format to string format Pauli Strings</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tuples (List of Tuples):</strong>  List of (pauliStrings) to Convert to text</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tuples</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.IO.paulilabel", "modulename": "CQS.util.IO", "qualname": "paulilabel", "type": "function", "doc": "<p>Transforms numbers in tuples to Pauli terms</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>p (Tuple):</strong>  The (PauliString) input</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>String: 'PauliString'</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.IO.tuplesToMatrix", "modulename": "CQS.util.IO", "qualname": "tuplesToMatrix", "type": "function", "doc": "<p>Converts a Pauli String represented as a Tuple to a matrix element that can be operated on traditionally. Generally expensive to operate with</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>coefficient (np.Complex128):</strong>  Multiplies the resultant matrix</li>\n<li>PauliTuple (Tuple)\nPauli Tuple of the form (0, 1, 2, 3) == IXYZ == kron(kron(kron(I, X), Y), Z)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ndarray, equal to the kronecker product of the Pauli elements, multiplied by the coefficients</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coefficient</span>, </span><span class=\"param\"><span class=\"n\">PauliTuple</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.PauliOps", "modulename": "CQS.util.PauliOps", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.util.PauliOps.ops", "modulename": "CQS.util.PauliOps", "qualname": "ops", "type": "variable", "doc": "<p>Indices for converting from (PauliString) --> String format</p>\n", "default_value": " = [&#x27;I&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;]"}, {"fullname": "CQS.util.PauliOps.RULES", "modulename": "CQS.util.PauliOps", "qualname": "RULES", "type": "variable", "doc": "<p>Used for generating the Commutator tables and pauli commutators (efficiently we think)\n``</p>\n\n<h6 id=\"rules\">RULES</h6>\n\n<blockquote>\n  <p>Used to find the multiplication between two paulis represented as indices in a tuple (I == 0, X == 1, Y == 2, Z == 3)</p>\n</blockquote>\n\n<p>The operation is (index1 + index2*RULES[index1] % 4) = Pauli Matrix result as an index</p>\n\n<p>I * anything: 0 + (Index2)<em>1 = index2\nX * anythong: (1 + (Index2)</em>3 % 4) gives\n                                         1 + 0 = 1 for I, \n                                         (1 + 1<em>3) % 4 = 0 for X\n                                         (1 + 2</em>3) % 4 = 7 % 4 = 3 for Y\n                                         (1 + 3*3) % 4 = 10 % 4 = 2 for Z as index2\nThese can easily be expanded for Y and Z\n``</p>\n", "default_value": " = [1, 3, 1, 3]"}, {"fullname": "CQS.util.PauliOps.SIGN_RULES", "modulename": "CQS.util.PauliOps", "qualname": "SIGN_RULES", "type": "variable", "doc": "<p>Rules for computing the sign of two commutators</p>\n\n<pre><code>SIGN_RULES: \n    Gives the multiplication sign rules for multiplying Pauli Matricies (ex. X*Y -&gt; iZ)\n\n  I  X  Y  Z\nI +  +  +  +\nX +  +  +i -i\nY +  -i +  +i\nZ +  +i -i +\n\nOrder: row * column\n</code></pre>\n", "default_value": " = [[1, 1, 1, 1], [1, 1, 1j, (-0-1j)], [1, (-0-1j), 1, 1j], [1, 1j, (-0-1j), 1]]"}, {"fullname": "CQS.util.PauliOps.commutatePauliString", "modulename": "CQS.util.PauliOps", "qualname": "commutatePauliString", "type": "function", "doc": "<p>Computes the commutator of two Pauli Strings representated as a tuple</p>\n\n<p>If a commutator table is passed, the operation is much more efficient</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple, integer):</strong>   tuple represenation of the first Pauli String, or the index in the commutator table</li>\n<li><strong>b (np.complex128):</strong>   The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (tuple, int):</strong>   tuple represenation of the second Pauli String, or the index in the commutator table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result [a<em>TupleA,b</em>TupleB] = c*TupleC, where c is the Structure Constant * a * b\n  tupleC (tuple): \n      the elementwise commutator of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">tupleA</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">tupleB</span>, </span><span class=\"param\"><span class=\"n\">comm_coefs</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">comm_table</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.multiplyPauliString", "modulename": "CQS.util.PauliOps", "qualname": "multiplyPauliString", "type": "function", "doc": "<p>Computes the multiplication of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple):</strong>  tuple represenation of the first Pauli String</li>\n<li><strong>b (np.complex128):</strong>  The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (Tuple):</strong>   tuple represenation of the second Pauli String</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result a<em>TupleA . b</em>TupleB = c*TupleC, where c (the sign of the product of Paulis * a * b)\n  tupleC (tuple) :\n      the elementwise product of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">tupleA</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">tupleB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.multiplyLinComb", "modulename": "CQS.util.PauliOps", "qualname": "multiplyLinComb", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">tuplesA</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">tuplesB</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.simplifyLinComb", "modulename": "CQS.util.PauliOps", "qualname": "simplifyLinComb", "type": "function", "doc": "<p>Modifies the input lists</p>\n\n<p>Simplifies lin comb of Pauli matrices that it eats. Doens't return anything</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>A:</strong>  A list</li>\n<li><strong>tuples:</strong>  A list</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">tuples</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.commutateLinComb", "modulename": "CQS.util.PauliOps", "qualname": "commutateLinComb", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">tuplesA</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">tuplesB</span>, </span><span class=\"param\"><span class=\"n\">accur</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.multiplyLinCombRound", "modulename": "CQS.util.PauliOps", "qualname": "multiplyLinCombRound", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms, and rounds things that are smaller than accur to zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">tuplesA</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">tuplesB</span>, </span><span class=\"param\"><span class=\"n\">accur</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.commutateLinCombWithoutFactorOf2", "modulename": "CQS.util.PauliOps", "qualname": "commutateLinCombWithoutFactorOf2", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">tuplesA</span>, </span><span class=\"param\"><span class=\"n\">B</span>, </span><span class=\"param\"><span class=\"n\">tuplesB</span>, </span><span class=\"param\"><span class=\"n\">accur</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.cleancoefs", "modulename": "CQS.util.PauliOps", "qualname": "cleancoefs", "type": "function", "doc": "<p>Rounds coefficients that are smaller than accur to zero.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coefs</span>, </span><span class=\"param\"><span class=\"n\">accur</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.verification", "modulename": "CQS.util.verification", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.util.verification.Nident", "modulename": "CQS.util.verification", "qualname": "Nident", "type": "function", "doc": "<p>Generates an N qubit Identity Matrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.verification.PauliExpUnitary", "modulename": "CQS.util.verification", "qualname": "PauliExpUnitary", "type": "function", "doc": "<p>Generates the Unitary Matrix for a Pauli Exponential\nUses e^{i.co.Pauli} = I<em>cos(a) + i</em>sin(a)*Pauli</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>N (int):</strong>  Number of qubits</li>\n<li><strong>co (float):</strong>  The coefficient of the Pauli Matrix</li>\n<li><strong>PauliTuple (Tuple):</strong>  (PauliString) to exp</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The result e<sup>i\u2022co\u2022PauliTuple</sup> = I\u2022cos(co) + i\u2022sin(co)\u2022PauliTuple</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">co</span>, </span><span class=\"param\"><span class=\"n\">PauliTuple</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.verification.exactU", "modulename": "CQS.util.verification", "qualname": "exactU", "type": "function", "doc": "<p>Computes the exact matrix exponential for time evolution at the time t. Takes as an input the real component of the exponential.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>HCos (List of complex numbers):</strong> </li>\n<li><strong>HTupes (List of (PauliStrings)):</strong> </li>\n<li><strong>time (float - time evolution final time):</strong> </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">HCos</span>, </span><span class=\"param\"><span class=\"n\">HTups</span>, </span><span class=\"param\"><span class=\"n\">time</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.verification.Trotter", "modulename": "CQS.util.verification", "qualname": "Trotter", "type": "function", "doc": "<p>Prepares U_t, the Trotterized input U</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>ham (List of Tuples):</strong>  Hamiltonian formatted as (co, (PauliString))</li>\n<li><strong>time (float):</strong>  final time to evolve to</li>\n<li><strong>N (int):</strong>  number of qubits</li>\n<li><strong>steps (int):</strong>  Number of trotter steps to take</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The U<sub>trotter</sub>(t) that approximates U<sub>exact</sub>(t)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ham</span>, </span><span class=\"param\"><span class=\"n\">time</span>, </span><span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">steps</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "CQS.util.verification.KHK", "modulename": "CQS.util.verification", "qualname": "KHK", "type": "function", "doc": "<p>Defines the Unitary for the KHK<sup>\u2020</sup>]</p>\n\n<p>Specifically, performs \u213f<sub>i</sub> e<sup>i\u2022k[l]\u2022kCoefs[l]</sup> \u213f<sub>j</sub> e<sup>i\u2022h[j]\u2022hCoefs[j]</sup>  \u213f<sub>l</sub> e<sup>i\u2022k[(lenK - l)]\u2022kCoefs[(lenK - l)]</sup> </p>\n\n<p>Multiply by t before passing the coefficients for h. Do not multiply h by i, that is automatic. The coefficients should be real for k, imaginary for h</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>kCoefs (List):</strong>  A list of (real) coefficients for k</li>\n<li><strong>hCoefs (List):</strong>  The list of (imaginary) coefficients for the elements in h. </li>\n<li><strong>k (List of Tuples):</strong>  The list of (PauliStrings)</li>\n<li><strong>h (List of Tuples):</strong>  List of (PauliStrings) for h (in the same indexing)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kCoefs</span>, </span><span class=\"param\"><span class=\"n\">hCoefs</span>, </span><span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">h</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();